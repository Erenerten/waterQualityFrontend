<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<title>AEA - Su Koruma Oyunu</title>
<style>
  body {
    background: linear-gradient(135deg, #667eea 0%, #1a4ec0 100%);
    color: white;
    font-family: 'Arial', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
    min-height: 100vh;
  }
  
  h1 {
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    margin-bottom: 10px;
  }
  
  #game-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 30px;
    flex-wrap: wrap;
  }
  
  #game {
    margin: 20px auto;
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    gap: 2px;
    padding: 10px;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    user-select: none;
  }
  
  .cell {
    width: 60px;
    height: 60px;
    border-radius: 12px;
    cursor: grab;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
  }
  
  .cell:hover {
    background: rgba(255,255,255,0.2);
    transform: scale(1.05);
  }
  
  .cell:active {
    cursor: grabbing;
    transform: scale(0.95);
  }
  
  .cell.drag-over {
    background: rgba(255,255,255,0.3);
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255,255,255,0.5);
  }
  
  .candy {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    transition: all 0.3s ease;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
  }
  
  .candy.red { 
    background-image: url('images2/red.png');
  }
  .candy.green { 
    background-image: url('images2/green.png');
  }
  .candy.blue { 
    background-image: url('images2/blue.png');
  }
  .candy.yellow { 
    background-image: url('images2/yellow.png');
  }
  .candy.purple { 
    background-image: url('images2/purple.png');
  }
  .candy.orange { 
    background-image: url('images2/orange.png');
  }
  
  .candy.fade-out {
    opacity: 0;
    transform: scale(0.5) rotate(180deg);
  }
  
  .candy.fade-in {
    opacity: 1;
    transform: scale(1) rotate(0deg);
  }
  
  #scoreboard {
    background: rgba(255,255,255,0.1);
    padding: 20px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    min-width: 200px;
  }
  
  #score {
    font-size: 2em;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    margin-bottom: 10px;
  }
  
  #combo {
    font-size: 1.2em;
    color: #ffd43b;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    margin-bottom: 15px;
  }
  
  #timer-container {
    background: rgba(255,255,255,0.1);
    padding: 15px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    width: 150px;
  }
  
  #progress-container {
    width: 30px;
    height: 200px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 15px;
    position: relative;
    background: rgba(0,0,0,0.2);
    margin: 10px auto;
  }
  
  #progressBar {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(to top, #ff4757, #ffa502, #2ed573, #70a1ff);
    border-radius: 0 0 13px 13px;
    transition: height 0.5s ease;
  }
  
  #timerText {
    font-size: 1.2em;
    font-weight: bold;
    margin-top: 10px;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  }
  
  #message-display {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #00b4db, #0083b0);
    color: white;
    padding: 15px 30px;
    border-radius: 25px;
    font-size: 1.3em;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    opacity: 0;
    transition: all 0.5s ease;
    z-index: 1000;
    pointer-events: none;
  }
  
  #message-display.show {
    opacity: 1;
    transform: translateX(-50%) translateY(-10px);
  }
  
  #rank-display {
    font-size: 1.4em;
    font-weight: bold;
    margin-top: 10px;
    padding: 10px;
    border-radius: 10px;
    background: rgba(255,255,255,0.1);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  }
  
  .rank-beginner { background: linear-gradient(135deg, #95a5a6, #7f8c8d); }
  .rank-protector { background: linear-gradient(135deg, #3498db, #2980b9); }
  .rank-guardian { background: linear-gradient(135deg, #9b59b6, #8e44ad); }
  .rank-fishman { background: linear-gradient(135deg, #e67e22, #d35400); }
  .rank-poseidon { background: linear-gradient(135deg, #f1c40f, #f39c12); }
  
  .match-animation {
    animation: matchPulse 0.5s ease-in-out;
  }
  
  @keyframes matchPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); box-shadow: 0 0 20px currentColor; }
    100% { transform: scale(1); }
  }
  
  .time-bonus {
    animation: timeBonusAnim 1s ease-out;
  }
  
  @keyframes timeBonusAnim {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); color: #2ed573; }
    100% { transform: scale(1); }
  }
  
  .instructions {
    background: rgba(255,255,255,0.1);
    padding: 15px;
    border-radius: 10px;
    backdrop-filter: blur(10px);
    margin-top: 20px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
  }
  
  #gameStatus {
    margin-top: 10px;
    font-weight: bold;
    font-size: 1.5em;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  }
</style>
</head>
<body>

<h1>💧 AEA - Su Koruma Görevi 💧</h1>

<div id="message-display"></div>

<div id="game-container">
  <div id="timer-container">
    <div>Kalan Süre</div>
    <div id="progress-container">
      <div id="progressBar"></div>
    </div>
    <div id="timerText">30s</div>
  </div>
  
  <div id="game"></div>
  
  <div id="scoreboard">
    <div id="score">Puan: 0</div>
    <div id="combo">Kombo: 0</div>
    <div id="rank-display" class="rank-beginner">🌊 Başlangıç</div>
  </div>
</div>

<div class="instructions">
  <strong>Su Koruma Görevi:</strong><br>
  Kirleticileri temizleyerek suyu koru! 4'lü eşleşme = +2 saniye bonus!<br>
  <small>3'lü: 30 puan | 4'lü: 60 puan + 2sn | 5'lü: 100 puan | 6+: 150+ puan</small><br>
  <strong>Rütbeler:</strong> 2000p: Su Koruyucusu | 2500p: Su Gardiyanı | 3000p: Balık Adam | 3500p: Poseidon
</div>

<div id="gameStatus"></div>

<script>
  let totalTime = 30;
  let timeLeft = totalTime;
  let gameActive = true;
  
  const progressBar = document.getElementById('progressBar');
  const timerText = document.getElementById('timerText');
  const gameStatus = document.getElementById('gameStatus');
  const messageDisplay = document.getElementById('message-display');
  const rankDisplay = document.getElementById('rank-display');

  const waterMessages = [
    "💧 Sular temizleniyor!",
    "🌊 Denizler korunuyor!",
    "🐟 Balıklar mutlu!",
    "💎 Su berrak kaldı!",
    "🌈 Okyanuslar güvende!",
    "⭐ Harika temizlik!",
    "🔮 Büyülü temizlik!",
    "🏆 Mükemmel koruma!",
    "🌟 Efsane temizlik!",
    "👑 Kraliyet temizliği!"
  ];

  function showMessage(text, isTimeBonus = false) {
    messageDisplay.textContent = text;
    messageDisplay.classList.add('show');
    
    if (isTimeBonus) {
      messageDisplay.style.background = 'linear-gradient(135deg, #2ed573, #1dd1a1)';
    } else {
      messageDisplay.style.background = 'linear-gradient(135deg, #00b4db, #0083b0)';
    }
    
    setTimeout(() => {
      messageDisplay.classList.remove('show');
    }, 2000);
  }

  function updateRank() {
    let rank = "🌊 Başlangıç";
    let rankClass = "rank-beginner";
    
    if (score >= 3500) {
      rank = "👑 Poseidon";
      rankClass = "rank-poseidon";
    } else if (score >= 3000) {
      rank = "🐟 Balık Adam";
      rankClass = "rank-fishman";
    } else if (score >= 2500) {
      rank = "🛡️ Su Gardiyanı";
      rankClass = "rank-guardian";
    } else if (score >= 2000) {
      rank = "⚔️ Su Koruyucusu";
      rankClass = "rank-protector";
    }
    
    if (rankDisplay.textContent !== rank) {
      rankDisplay.textContent = rank;
      rankDisplay.className = rankClass;
      if (score >= 2000) {
        showMessage(`🎉 Tebrikler! ${rank} rütbesine ulaştın!`);
      }
    }
  }

  function addTimeBonus(seconds) {
    timeLeft = Math.min(timeLeft + seconds, totalTime + 10); // Max 40 saniye
    timerText.classList.add('time-bonus');
    showMessage(`⏰ +${seconds} saniye bonus!`, true);
    
    setTimeout(() => {
      timerText.classList.remove('time-bonus');
    }, 1000);
  }

  const intervalId = setInterval(() => {
    if (!gameActive) return;
    
    timeLeft--;
    timerText.innerText = timeLeft + "s";
    
    let heightPercent = (timeLeft / totalTime) * 100;
    progressBar.style.height = Math.max(0, heightPercent) + "%";
    
    if (timeLeft <= 0) {
      clearInterval(intervalId);
      gameActive = false;
      gameStatus.innerText = "🏁 Oyun Bitti! Final Puanın: " + score;
      timerText.innerText = "0s";
      progressBar.style.height = "0%";
      
      // Final rütbe kontrolü
      updateRank();
      
      // Oyun bittiğinde drag&drop'u devre dışı bırak
      const cells = document.querySelectorAll('.cell');
      cells.forEach(cell => {
        cell.setAttribute('draggable', false);
        cell.style.opacity = '0.7';
        cell.style.cursor = 'not-allowed';
      });
    }
  }, 1000);

  const rows = 8;
  const cols = 8;
  const colors = ["red", "green", "blue", "yellow", "purple", "orange"];

  let grid = [];
  let score = 0;
  let combo = 0;

  const game = document.getElementById("game");
  const scoreElement = document.getElementById("score");
  const comboElement = document.getElementById("combo");

  function randomColor() {
    return colors[Math.floor(Math.random() * colors.length)];
  }

  function createGrid() {
    game.innerHTML = "";
    grid = [];
    
    for(let r = 0; r < rows; r++) {
      let row = [];
      for(let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = r;
        cell.dataset.col = c;
        
        let color;
        let attempts = 0;
        do {
          color = randomColor();
          attempts++;
          if (attempts > 50) break;
        } while (wouldCreateMatch(r, c, color) && attempts < 50);
        
        cell.dataset.color = color;

        const candy = document.createElement("div");
        candy.classList.add("candy", color);
        cell.appendChild(candy);

        cell.setAttribute("draggable", true);
        cell.addEventListener("dragstart", dragStart);
        cell.addEventListener("dragover", dragOver);
        cell.addEventListener("drop", drop);
        cell.addEventListener("dragenter", dragEnter);
        cell.addEventListener("dragleave", dragLeave);

        game.appendChild(cell);
        row.push(cell);
      }
      grid.push(row);
    }
    
    setTimeout(() => {
      handleMatches();
    }, 500);
  }

  function wouldCreateMatch(row, col, color) {
    let leftCount = 0;
    for(let c = col - 1; c >= 0; c--) {
      if (grid[row] && grid[row][c] && grid[row][c].dataset.color === color) {
        leftCount++;
      } else {
        break;
      }
    }
    
    let rightCount = 0;
    for(let c = col + 1; c < cols; c++) {
      if (grid[row] && grid[row][c] && grid[row][c].dataset.color === color) {
        rightCount++;
      } else {
        break;
      }
    }
    
    let upCount = 0;
    for(let r = row - 1; r >= 0; r--) {
      if (grid[r] && grid[r][col] && grid[r][col].dataset.color === color) {
        upCount++;
      } else {
        break;
      }
    }
    
    let downCount = 0;
    for(let r = row + 1; r < rows; r++) {
      if (grid[r] && grid[r][col] && grid[r][col].dataset.color === color) {
        downCount++;
      } else {
        break;
      }
    }
    
    return (leftCount + rightCount >= 2) || (upCount + downCount >= 2);
  }

  let draggedCell = null;

  function dragStart(e) {
    if (!gameActive) return false;
    draggedCell = e.currentTarget;
    e.currentTarget.style.opacity = "0.7";
  }

  function dragOver(e) {
    e.preventDefault();
  }

  function dragEnter(e) {
    e.preventDefault();
    if (e.currentTarget !== draggedCell) {
      e.currentTarget.classList.add("drag-over");
    }
  }

  function dragLeave(e) {
    e.currentTarget.classList.remove("drag-over");
  }

  function drop(e) {
    if (!gameActive) return;
    
    e.preventDefault();
    e.currentTarget.classList.remove("drag-over");

    const targetCell = e.currentTarget;
    if (!draggedCell || targetCell === draggedCell) {
      if (draggedCell) draggedCell.style.opacity = "1";
      return;
    }

    const r1 = parseInt(draggedCell.dataset.row);
    const c1 = parseInt(draggedCell.dataset.col);
    const r2 = parseInt(targetCell.dataset.row);
    const c2 = parseInt(targetCell.dataset.col);

    const isAdjacent = (Math.abs(r1 - r2) + Math.abs(c1 - c2)) === 1;
    if (!isAdjacent) {
      draggedCell.style.opacity = "1";
      return;
    }

    swapCells(draggedCell, targetCell).then(() => {
      draggedCell.style.opacity = "1";
      
      if (checkMatches()) {
        handleMatches();
      } else {
        setTimeout(() => {
          swapCells(draggedCell, targetCell);
        }, 200);
      }
    });
  }

  function swapCells(cell1, cell2) {
    return new Promise(resolve => {
      const color1 = cell1.dataset.color;
      const color2 = cell2.dataset.color;
      const candy1 = cell1.querySelector('.candy');
      const candy2 = cell2.querySelector('.candy');

      candy1.classList.add('fade-out');
      candy2.classList.add('fade-out');

      setTimeout(() => {
        cell1.dataset.color = color2;
        cell2.dataset.color = color1;
        
        candy1.className = `candy ${color2}`;
        candy2.className = `candy ${color1}`;
        
        candy1.classList.add('fade-in');
        candy2.classList.add('fade-in');
        
        setTimeout(() => {
          candy1.classList.remove('fade-out', 'fade-in');
          candy2.classList.remove('fade-out', 'fade-in');
          resolve();
        }, 300);
      }, 300);
    });
  }

  function checkMatches() {
    return findAllMatches().length > 0;
  }

  function findAllMatches() {
    let matches = new Set();
    
    for(let r = 0; r < rows; r++) {
      let count = 1;
      let currentColor = grid[r][0].dataset.color;
      let startCol = 0;
      
      for(let c = 1; c < cols; c++) {
        if (grid[r][c].dataset.color === currentColor && currentColor !== "") {
          count++;
        } else {
          if (count >= 3) {
            for(let i = startCol; i < startCol + count; i++) {
              matches.add(`${r},${i}`);
            }
          }
          currentColor = grid[r][c].dataset.color;
          startCol = c;
          count = 1;
        }
      }
      
      if (count >= 3) {
        for(let i = startCol; i < startCol + count; i++) {
          matches.add(`${r},${i}`);
        }
      }
    }
    
    for(let c = 0; c < cols; c++) {
      let count = 1;
      let currentColor = grid[0][c].dataset.color;
      let startRow = 0;
      
      for(let r = 1; r < rows; r++) {
        if (grid[r][c].dataset.color === currentColor && currentColor !== "") {
          count++;
        } else {
          if (count >= 3) {
            for(let i = startRow; i < startRow + count; i++) {
              matches.add(`${i},${c}`);
            }
          }
          currentColor = grid[r][c].dataset.color;
          startRow = r;
          count = 1;
        }
      }
      
      if (count >= 3) {
        for(let i = startRow; i < startRow + count; i++) {
          matches.add(`${i},${c}`);
        }
      }
    }
    
    return [...matches].map(str => str.split(",").map(Number));
  }

  function clearMatches() {
    return new Promise(resolve => {
      const matches = findAllMatches();

      if (matches.length === 0) {
        combo = 0;
        updateScore();
        resolve(false);
        return;
      }

      const MAX_COMBO = 5;
      combo = Math.min(combo + 1, MAX_COMBO);

      matches.forEach(([r, c]) => {
        const cell = grid[r][c];
        const candy = cell.querySelector('.candy');
        candy.classList.add('match-animation');
      });

      setTimeout(() => {
        matches.forEach(([r, c]) => {
          const cell = grid[r][c];
          const candy = cell.querySelector('.candy');
          cell.dataset.color = "";
          candy.classList.add('fade-out');
        });

        let points = 0;
        let isQuadMatch = matches.length === 4;
        
        if (matches.length >= 6) {
          points = 150 + (matches.length - 6) * 25;
        } else if (matches.length === 5) {
          points = 100;
        } else if (matches.length === 4) {
          points = 60;
          // 4'lü eşleşmede süre bonusu
          if (gameActive) {
            addTimeBonus(2);
          }
        } else {
          points = 30;
        }
        
        score += points * combo;
        updateScore();
        updateRank();
        
        // Su temalı mesaj göster
        if (!isQuadMatch) { // 4'lü eşleşmede ayrı mesaj var
          const randomMessage = waterMessages[Math.floor(Math.random() * waterMessages.length)];
          showMessage(randomMessage);
        }

        setTimeout(() => {
          resolve(true);
        }, 400);
      }, 500);
    });
  }

  function dropCells() {
    return new Promise(resolve => {
      for(let c = 0; c < cols; c++) {
        for(let r = rows - 1; r >= 0; r--) {
          if (grid[r][c].dataset.color === "") {
            for(let rr = r - 1; rr >= 0; rr--) {
              if(grid[rr][c].dataset.color !== "") {
                const color = grid[rr][c].dataset.color;
                const candyFrom = grid[rr][c].querySelector('.candy');
                const candyTo = grid[r][c].querySelector('.candy');

                grid[r][c].dataset.color = color;
                candyTo.className = `candy ${color}`;
                candyTo.classList.add('fade-in');

                grid[rr][c].dataset.color = "";
                candyFrom.classList.add('fade-out');
                
                setTimeout(() => {
                  candyFrom.classList.remove('fade-out');
                  candyTo.classList.remove('fade-in');
                }, 300);
                break;
              }
            }
          }
        }
      }
      setTimeout(resolve, 350);
    });
  }

  function fillGrid() {
    return new Promise(resolve => {
      for(let r = 0; r < rows; r++) {
        for(let c = 0; c < cols; c++) {
          if(grid[r][c].dataset.color === "") {
            const color = randomColor();
            const candy = grid[r][c].querySelector('.candy');
            grid[r][c].dataset.color = color;
            candy.className = `candy ${color}`;
            candy.classList.add('fade-in');
            
            setTimeout(() => {
              candy.classList.remove('fade-in');
            }, 300);
          }
        }
      }
      setTimeout(resolve, 350);
    });
  }

  async function handleMatches() {
    while (true) {
      let cleared = await clearMatches();
      if (!cleared) break;
      await dropCells();
      await fillGrid();
    }
  }

  function updateScore() {
    scoreElement.textContent = `Puan: ${score}`;
    comboElement.textContent = `Kombo: ${combo}`;
    
    if (combo > 1) {
      comboElement.style.color = "#ff6b6b";
      comboElement.style.fontSize = "1.4em";
      setTimeout(() => {
        comboElement.style.color = "#ffd43b";
        comboElement.style.fontSize = "1.2em";
      }, 500);
    }
  }

  // Oyunu başlat
  createGrid();
</script>

</body>
</html>